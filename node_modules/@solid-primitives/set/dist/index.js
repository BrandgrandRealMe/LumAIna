import { batch } from 'solid-js';
import { TriggerCache } from '@solid-primitives/trigger';

// src/index.ts
var $KEYS = Symbol("track-keys");
var ReactiveSet = class extends Set {
  #triggers = new TriggerCache();
  constructor(values) {
    super();
    if (values)
      for (const v of values)
        super.add(v);
  }
  // reads
  get size() {
    this.#triggers.track($KEYS);
    return super.size;
  }
  has(v) {
    this.#triggers.track(v);
    return super.has(v);
  }
  *keys() {
    for (const key of super.keys()) {
      this.#triggers.track(key);
      yield key;
    }
    this.#triggers.track($KEYS);
  }
  values() {
    return this.keys();
  }
  *entries() {
    for (const key of super.keys()) {
      this.#triggers.track(key);
      yield [key, key];
    }
    this.#triggers.track($KEYS);
  }
  [Symbol.iterator]() {
    return this.values();
  }
  forEach(callbackfn) {
    this.#triggers.track($KEYS);
    super.forEach(callbackfn);
  }
  // writes
  add(v) {
    if (!super.has(v)) {
      super.add(v);
      batch(() => {
        this.#triggers.dirty(v);
        this.#triggers.dirty($KEYS);
      });
    }
    return this;
  }
  delete(v) {
    const r = super.delete(v);
    if (r) {
      batch(() => {
        this.#triggers.dirty(v);
        this.#triggers.dirty($KEYS);
      });
    }
    return r;
  }
  clear() {
    if (super.size) {
      batch(() => {
        for (const v of super.keys())
          this.#triggers.dirty(v);
        super.clear();
        this.#triggers.dirty($KEYS);
      });
    }
  }
};
var ReactiveWeakSet = class extends WeakSet {
  #triggers = new TriggerCache(WeakMap);
  constructor(values) {
    super();
    if (values)
      for (const v of values)
        super.add(v);
  }
  has(v) {
    this.#triggers.track(v);
    return super.has(v);
  }
  add(v) {
    if (!super.has(v)) {
      super.add(v);
      this.#triggers.dirty(v);
    }
    return this;
  }
  delete(v) {
    const deleted = super.delete(v);
    deleted && this.#triggers.dirty(v);
    return deleted;
  }
};
function createSet(initial) {
  const set = new ReactiveSet(initial);
  return new Proxy(() => [...set], {
    get: (_, b) => set[b]
  });
}
function createWeakSet(initial) {
  return new ReactiveWeakSet(initial);
}

export { ReactiveSet, ReactiveWeakSet, createSet, createWeakSet };
