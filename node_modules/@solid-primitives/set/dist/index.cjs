'use strict';

var solidJs = require('solid-js');
var trigger = require('@solid-primitives/trigger');

// src/index.ts
var $KEYS = Symbol("track-keys");
exports.ReactiveSet = class ReactiveSet extends Set {
  #triggers = new trigger.TriggerCache();
  constructor(values) {
    super();
    if (values)
      for (const v of values)
        super.add(v);
  }
  // reads
  get size() {
    this.#triggers.track($KEYS);
    return super.size;
  }
  has(v) {
    this.#triggers.track(v);
    return super.has(v);
  }
  *keys() {
    for (const key of super.keys()) {
      this.#triggers.track(key);
      yield key;
    }
    this.#triggers.track($KEYS);
  }
  values() {
    return this.keys();
  }
  *entries() {
    for (const key of super.keys()) {
      this.#triggers.track(key);
      yield [key, key];
    }
    this.#triggers.track($KEYS);
  }
  [Symbol.iterator]() {
    return this.values();
  }
  forEach(callbackfn) {
    this.#triggers.track($KEYS);
    super.forEach(callbackfn);
  }
  // writes
  add(v) {
    if (!super.has(v)) {
      super.add(v);
      solidJs.batch(() => {
        this.#triggers.dirty(v);
        this.#triggers.dirty($KEYS);
      });
    }
    return this;
  }
  delete(v) {
    const r = super.delete(v);
    if (r) {
      solidJs.batch(() => {
        this.#triggers.dirty(v);
        this.#triggers.dirty($KEYS);
      });
    }
    return r;
  }
  clear() {
    if (super.size) {
      solidJs.batch(() => {
        for (const v of super.keys())
          this.#triggers.dirty(v);
        super.clear();
        this.#triggers.dirty($KEYS);
      });
    }
  }
};
exports.ReactiveWeakSet = class ReactiveWeakSet extends WeakSet {
  #triggers = new trigger.TriggerCache(WeakMap);
  constructor(values) {
    super();
    if (values)
      for (const v of values)
        super.add(v);
  }
  has(v) {
    this.#triggers.track(v);
    return super.has(v);
  }
  add(v) {
    if (!super.has(v)) {
      super.add(v);
      this.#triggers.dirty(v);
    }
    return this;
  }
  delete(v) {
    const deleted = super.delete(v);
    deleted && this.#triggers.dirty(v);
    return deleted;
  }
};
function createSet(initial) {
  const set = new exports.ReactiveSet(initial);
  return new Proxy(() => [...set], {
    get: (_, b) => set[b]
  });
}
function createWeakSet(initial) {
  return new exports.ReactiveWeakSet(initial);
}

exports.createSet = createSet;
exports.createWeakSet = createWeakSet;
