"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _Channel_collection, _Channel_ackTimeout, _Channel_ackLimit;
Object.defineProperty(exports, "__esModule", { value: true });
exports.Channel = void 0;
const solid_js_1 = require("solid-js");
const ulid_1 = require("ulid");
const calculator_1 = require("../permissions/calculator");
const definitions_1 = require("../permissions/definitions");
/**
 * Channel Class
 */
class Channel {
    /**
     * Construct Channel
     * @param collection Collection
     * @param id Channel Id
     */
    constructor(collection, id) {
        _Channel_collection.set(this, void 0);
        _Channel_ackTimeout.set(this, void 0);
        _Channel_ackLimit.set(this, void 0);
        __classPrivateFieldSet(this, _Channel_collection, collection, "f");
        this.id = id;
    }
    /**
     * Write to string as a channel mention
     * @returns Formatted String
     */
    toString() {
        return `<#${this.id}>`;
    }
    /**
     * Time when this server was created
     */
    get createdAt() {
        return new Date((0, ulid_1.decodeTime)(this.id));
    }
    /**
     * Channel type
     */
    get type() {
        return __classPrivateFieldGet(this, _Channel_collection, "f").getUnderlyingObject(this.id).channelType;
    }
    /**
     * Absolute pathname to this channel in the client
     */
    get path() {
        if (this.serverId) {
            return `/server/${this.serverId}/channel/${this.id}`;
        }
        else {
            return `/channel/${this.id}`;
        }
    }
    /**
     * URL to this channel
     */
    get url() {
        var _a;
        return ((_a = __classPrivateFieldGet(this, _Channel_collection, "f").client.configuration) === null || _a === void 0 ? void 0 : _a.app) + this.path;
    }
    /**
     * Channel name
     */
    get name() {
        return __classPrivateFieldGet(this, _Channel_collection, "f").getUnderlyingObject(this.id).name;
    }
    /**
     * Display name
     */
    get displayName() {
        var _a, _b;
        return this.type === "SavedMessages"
            ? (_a = this.user) === null || _a === void 0 ? void 0 : _a.username
            : this.type === "DirectMessage"
                ? (_b = this.recipient) === null || _b === void 0 ? void 0 : _b.username
                : this.name;
    }
    /**
     * Channel description
     */
    get description() {
        return __classPrivateFieldGet(this, _Channel_collection, "f").getUnderlyingObject(this.id).description;
    }
    /**
     * Channel icon
     */
    get icon() {
        return __classPrivateFieldGet(this, _Channel_collection, "f").getUnderlyingObject(this.id).icon;
    }
    /**
     * Whether the conversation is active
     */
    get active() {
        return __classPrivateFieldGet(this, _Channel_collection, "f").getUnderlyingObject(this.id).active;
    }
    /**
     * User ids of people currently typing in channel
     */
    get typingIds() {
        return __classPrivateFieldGet(this, _Channel_collection, "f").getUnderlyingObject(this.id).typingIds;
    }
    /**
     * Users currently trying in channel
     */
    get typing() {
        return [...this.typingIds.values()].map((id) => __classPrivateFieldGet(this, _Channel_collection, "f").client.users.get(id));
    }
    /**
     * User ids of recipients of the group
     */
    get recipientIds() {
        return __classPrivateFieldGet(this, _Channel_collection, "f").getUnderlyingObject(this.id).recipientIds;
    }
    /**
     * Recipients of the group
     */
    get recipients() {
        return [
            ...__classPrivateFieldGet(this, _Channel_collection, "f").getUnderlyingObject(this.id).recipientIds.values(),
        ].map((id) => __classPrivateFieldGet(this, _Channel_collection, "f").client.users.get(id));
    }
    /**
     * Find recipient of this DM
     */
    get recipient() {
        var _a;
        return this.type === "DirectMessage"
            ? (_a = this.recipients) === null || _a === void 0 ? void 0 : _a.find((user) => (user === null || user === void 0 ? void 0 : user.id) !== __classPrivateFieldGet(this, _Channel_collection, "f").client.user.id)
            : undefined;
    }
    /**
     * User ID
     */
    get userId() {
        return __classPrivateFieldGet(this, _Channel_collection, "f").getUnderlyingObject(this.id).userId;
    }
    /**
     * User this channel belongs to
     */
    get user() {
        return __classPrivateFieldGet(this, _Channel_collection, "f").client.users.get(__classPrivateFieldGet(this, _Channel_collection, "f").getUnderlyingObject(this.id).userId);
    }
    /**
     * Owner ID
     */
    get ownerId() {
        return __classPrivateFieldGet(this, _Channel_collection, "f").getUnderlyingObject(this.id).ownerId;
    }
    /**
     * Owner of the group
     */
    get owner() {
        return __classPrivateFieldGet(this, _Channel_collection, "f").client.users.get(__classPrivateFieldGet(this, _Channel_collection, "f").getUnderlyingObject(this.id).ownerId);
    }
    /**
     * Server ID
     */
    get serverId() {
        return __classPrivateFieldGet(this, _Channel_collection, "f").getUnderlyingObject(this.id).serverId;
    }
    /**
     * Server this channel is in
     */
    get server() {
        return __classPrivateFieldGet(this, _Channel_collection, "f").client.servers.get(__classPrivateFieldGet(this, _Channel_collection, "f").getUnderlyingObject(this.id).serverId);
    }
    /**
     * Permissions allowed for users in this group
     */
    get permissions() {
        return __classPrivateFieldGet(this, _Channel_collection, "f").getUnderlyingObject(this.id).permissions;
    }
    /**
     * Default permissions for this server channel
     */
    get defaultPermissions() {
        return __classPrivateFieldGet(this, _Channel_collection, "f").getUnderlyingObject(this.id).defaultPermissions;
    }
    /**
     * Role permissions for this server channel
     */
    get rolePermissions() {
        return __classPrivateFieldGet(this, _Channel_collection, "f").getUnderlyingObject(this.id).rolePermissions;
    }
    /**
     * Whether this channel is marked as mature
     */
    get mature() {
        return __classPrivateFieldGet(this, _Channel_collection, "f").getUnderlyingObject(this.id).nsfw;
    }
    /**
     * ID of the last message sent in this channel
     */
    get lastMessageId() {
        return __classPrivateFieldGet(this, _Channel_collection, "f").getUnderlyingObject(this.id).lastMessageId;
    }
    /**
     * Last message sent in this channel
     */
    get lastMessage() {
        return __classPrivateFieldGet(this, _Channel_collection, "f").client.messages.get(this.lastMessageId);
    }
    /**
     * Time when the last message was sent
     */
    get lastMessageAt() {
        return this.lastMessageId
            ? new Date((0, ulid_1.decodeTime)(this.lastMessageId))
            : undefined;
    }
    /**
     * Time when the channel was last updated (either created or a message was sent)
     */
    get updatedAt() {
        var _a;
        return (_a = this.lastMessageAt) !== null && _a !== void 0 ? _a : this.createdAt;
    }
    /**
     * Get whether this channel is unread.
     */
    get unread() {
        var _a, _b;
        if (!this.lastMessageId ||
            this.type === "SavedMessages" ||
            this.type === "VoiceChannel" ||
            __classPrivateFieldGet(this, _Channel_collection, "f").client.options.channelIsMuted(this))
            return false;
        return (((_b = (_a = __classPrivateFieldGet(this, _Channel_collection, "f").client.channelUnreads.get(this.id)) === null || _a === void 0 ? void 0 : _a.lastMessageId) !== null && _b !== void 0 ? _b : "0").localeCompare(this.lastMessageId) === -1);
    }
    /**
     * Get mentions in this channel for user.
     */
    get mentions() {
        var _a;
        if (this.type === "SavedMessages" || this.type === "VoiceChannel")
            return undefined;
        return (_a = __classPrivateFieldGet(this, _Channel_collection, "f").client.channelUnreads.get(this.id)) === null || _a === void 0 ? void 0 : _a.messageMentionIds;
    }
    /**
     * URL to the channel icon
     */
    get iconURL() {
        var _a, _b, _c;
        return ((_b = (_a = this.icon) === null || _a === void 0 ? void 0 : _a.createFileURL({ max_side: 256 })) !== null && _b !== void 0 ? _b : (_c = this.recipient) === null || _c === void 0 ? void 0 : _c.avatarURL);
    }
    /**
     * URL to a small variant of the channel icon
     */
    get smallIconURL() {
        var _a;
        return (_a = this.icon) === null || _a === void 0 ? void 0 : _a.createFileURL({ max_side: 64 });
    }
    /**
     * URL to the animated channel icon
     */
    get animatedIconURL() {
        var _a, _b, _c;
        return ((_b = (_a = this.icon) === null || _a === void 0 ? void 0 : _a.createFileURL({ max_side: 256 }, true)) !== null && _b !== void 0 ? _b : (_c = this.recipient) === null || _c === void 0 ? void 0 : _c.animatedAvatarURL);
    }
    /**
     * Whether this channel may be hidden to some users
     */
    get potentiallyRestrictedChannel() {
        var _a, _b, _c, _d;
        if (!this.serverId)
            return false;
        return ((0, calculator_1.bitwiseAndEq)((_b = (_a = this.defaultPermissions) === null || _a === void 0 ? void 0 : _a.d) !== null && _b !== void 0 ? _b : 0, definitions_1.Permission.ViewChannel) ||
            !(0, calculator_1.bitwiseAndEq)(this.server.defaultPermissions, definitions_1.Permission.ViewChannel) ||
            [...((_d = (_c = this.server) === null || _c === void 0 ? void 0 : _c.roles.keys()) !== null && _d !== void 0 ? _d : [])].find((role) => {
                var _a, _b, _c, _d, _e, _f;
                return (0, calculator_1.bitwiseAndEq)((_c = (_b = (_a = this.rolePermissions) === null || _a === void 0 ? void 0 : _a[role]) === null || _b === void 0 ? void 0 : _b.d) !== null && _c !== void 0 ? _c : 0, definitions_1.Permission.ViewChannel) ||
                    (0, calculator_1.bitwiseAndEq)((_f = (_e = (_d = this.server) === null || _d === void 0 ? void 0 : _d.roles.get(role)) === null || _e === void 0 ? void 0 : _e.permissions.d) !== null && _f !== void 0 ? _f : 0, definitions_1.Permission.ViewChannel);
            }));
    }
    /**
     * Permission the currently authenticated user has against this channel
     */
    get permission() {
        return (0, calculator_1.calculatePermission)(__classPrivateFieldGet(this, _Channel_collection, "f").client, this);
    }
    /**
     * Check whether we have a given permission in a channel
     * @param permission Permission Names
     * @returns Whether we have this permission
     */
    havePermission(...permission) {
        return (0, calculator_1.bitwiseAndEq)(this.permission, ...permission.map((x) => definitions_1.Permission[x]));
    }
    /**
     * Check whether we have at least one of the given permissions in a channel
     * @param permission Permission Names
     * @returns Whether we have one of the permissions
     */
    orPermission(...permission) {
        return (permission.findIndex((x) => (0, calculator_1.bitwiseAndEq)(this.permission, definitions_1.Permission[x])) !== -1);
    }
    /**
     * Fetch a channel's members.
     * @requires `Group`
     * @returns An array of the channel's members.
     */
    fetchMembers() {
        return __awaiter(this, void 0, void 0, function* () {
            const members = yield __classPrivateFieldGet(this, _Channel_collection, "f").client.api.get(`/channels/${this.id}/members`);
            return (0, solid_js_1.batch)(() => members.map((user) => __classPrivateFieldGet(this, _Channel_collection, "f").client.users.getOrCreate(user._id, user)));
        });
    }
    /**
     * Fetch a channel's webhooks
     * @requires `TextChannel`, `Group`
     * @returns Webhooks
     */
    fetchWebhooks() {
        return __awaiter(this, void 0, void 0, function* () {
            const webhooks = yield __classPrivateFieldGet(this, _Channel_collection, "f").client.api.get(`/channels/${this.id}/webhooks`);
            return (0, solid_js_1.batch)(() => webhooks.map((webhook) => __classPrivateFieldGet(this, _Channel_collection, "f").client.channelWebhooks.getOrCreate(webhook.id, webhook)));
        });
    }
    /**
     * Edit a channel
     * @param data Changes
     */
    edit(data) {
        return __awaiter(this, void 0, void 0, function* () {
            yield __classPrivateFieldGet(this, _Channel_collection, "f").client.api.patch(`/channels/${this.id}`, data);
        });
    }
    /**
     * Delete or leave a channel
     * @param leaveSilently Whether to not send a message on leave
     * @requires `DirectMessage`, `Group`, `TextChannel`, `VoiceChannel`
     */
    delete(leaveSilently) {
        return __awaiter(this, void 0, void 0, function* () {
            yield __classPrivateFieldGet(this, _Channel_collection, "f").client.api.delete(`/channels/${this.id}`, {
                leave_silently: leaveSilently,
            });
            if (this.type === "DirectMessage") {
                __classPrivateFieldGet(this, _Channel_collection, "f").updateUnderlyingObject(this.id, "active", false);
                return;
            }
            __classPrivateFieldGet(this, _Channel_collection, "f").delete(this.id);
        });
    }
    /**
     * Add a user to a group
     * @param user_id ID of the target user
     * @requires `Group`
     */
    addMember(user_id) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield __classPrivateFieldGet(this, _Channel_collection, "f").client.api.put(`/channels/${this.id}/recipients/${user_id}`);
        });
    }
    /**
     * Remove a user from a group
     * @param user_id ID of the target user
     * @requires `Group`
     */
    removeMember(user_id) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield __classPrivateFieldGet(this, _Channel_collection, "f").client.api.delete(`/channels/${this.id}/recipients/${user_id}`);
        });
    }
    /**
     * Send a message
     * @param data Either the message as a string or message sending route data
     * @requires `SavedMessages`, `DirectMessage`, `Group`, `TextChannel`
     * @returns Sent message
     */
    sendMessage(data, idempotencyKey = (0, ulid_1.ulid)()) {
        return __awaiter(this, void 0, void 0, function* () {
            const msg = typeof data === "string" ? { content: data } : data;
            const message = yield __classPrivateFieldGet(this, _Channel_collection, "f").client.api.post(`/channels/${this.id}/messages`, msg, {
                headers: {
                    "Idempotency-Key": idempotencyKey,
                },
            });
            return __classPrivateFieldGet(this, _Channel_collection, "f").client.messages.getOrCreate(message._id, message, true);
        });
    }
    /**
     * Fetch a message by its ID
     * @param messageId ID of the target message
     * @requires `SavedMessages`, `DirectMessage`, `Group`, `TextChannel`
     * @returns Message
     */
    fetchMessage(messageId) {
        return __awaiter(this, void 0, void 0, function* () {
            const message = yield __classPrivateFieldGet(this, _Channel_collection, "f").client.api.get(`/channels/${this.id}/messages/${messageId}`);
            return __classPrivateFieldGet(this, _Channel_collection, "f").client.messages.getOrCreate(message._id, message);
        });
    }
    /**
     * Fetch multiple messages from a channel
     * @param params Message fetching route data
     * @requires `SavedMessages`, `DirectMessage`, `Group`, `TextChannel`
     * @returns Messages
     */
    fetchMessages(params) {
        return __awaiter(this, void 0, void 0, function* () {
            const messages = (yield __classPrivateFieldGet(this, _Channel_collection, "f").client.api.get(`/channels/${this.id}/messages`, Object.assign({}, params)));
            return messages.map((message) => __classPrivateFieldGet(this, _Channel_collection, "f").client.messages.getOrCreate(message._id, message));
        });
    }
    /**
     * Fetch multiple messages from a channel including the users that sent them
     * @param params Message fetching route data
     * @requires `SavedMessages`, `DirectMessage`, `Group`, `TextChannel`
     * @returns Object including messages and users
     */
    fetchMessagesWithUsers(params) {
        return __awaiter(this, void 0, void 0, function* () {
            const data = (yield __classPrivateFieldGet(this, _Channel_collection, "f").client.api.get(`/channels/${this.id}/messages`, Object.assign(Object.assign({}, params), { include_users: true })));
            return (0, solid_js_1.batch)(() => {
                var _a;
                return ({
                    messages: data.messages.map((message) => __classPrivateFieldGet(this, _Channel_collection, "f").client.messages.getOrCreate(message._id, message)),
                    users: data.users.map((user) => __classPrivateFieldGet(this, _Channel_collection, "f").client.users.getOrCreate(user._id, user)),
                    members: (_a = data.members) === null || _a === void 0 ? void 0 : _a.map((member) => __classPrivateFieldGet(this, _Channel_collection, "f").client.serverMembers.getOrCreate(member._id, member)),
                });
            });
        });
    }
    /**
     * Search for messages
     * @param params Message searching route data
     * @requires `SavedMessages`, `DirectMessage`, `Group`, `TextChannel`
     * @returns Messages
     */
    search(params) {
        return __awaiter(this, void 0, void 0, function* () {
            const messages = (yield __classPrivateFieldGet(this, _Channel_collection, "f").client.api.post(`/channels/${this.id}/search`, params));
            return (0, solid_js_1.batch)(() => messages.map((message) => __classPrivateFieldGet(this, _Channel_collection, "f").client.messages.getOrCreate(message._id, message)));
        });
    }
    /**
     * Search for messages including the users that sent them
     * @param params Message searching route data
     * @requires `SavedMessages`, `DirectMessage`, `Group`, `TextChannel`
     * @returns Object including messages and users
     */
    searchWithUsers(params) {
        return __awaiter(this, void 0, void 0, function* () {
            const data = (yield __classPrivateFieldGet(this, _Channel_collection, "f").client.api.post(`/channels/${this.id}/search`, Object.assign(Object.assign({}, params), { include_users: true })));
            return (0, solid_js_1.batch)(() => {
                var _a;
                return ({
                    messages: data.messages.map((message) => __classPrivateFieldGet(this, _Channel_collection, "f").client.messages.getOrCreate(message._id, message)),
                    users: data.users.map((user) => __classPrivateFieldGet(this, _Channel_collection, "f").client.users.getOrCreate(user._id, user)),
                    members: (_a = data.members) === null || _a === void 0 ? void 0 : _a.map((member) => __classPrivateFieldGet(this, _Channel_collection, "f").client.serverMembers.getOrCreate(member._id, member)),
                });
            });
        });
    }
    /**
     * Delete many messages by their IDs
     * @param ids List of message IDs
     * @requires `SavedMessages`, `DirectMessage`, `Group`, `TextChannel`
     */
    deleteMessages(ids) {
        return __awaiter(this, void 0, void 0, function* () {
            yield __classPrivateFieldGet(this, _Channel_collection, "f").client.api.delete(`/channels/${this.id}/messages/bulk`, {
                ids,
            });
        });
    }
    /**
     * Create an invite to the channel
     * @requires `TextChannel`, `VoiceChannel`
     * @returns Newly created invite code
     */
    createInvite() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield __classPrivateFieldGet(this, _Channel_collection, "f").client.api.post(`/channels/${this.id}/invites`);
        });
    }
    /**
     * Mark a channel as read
     * @param message Last read message or its ID
     * @param skipRateLimiter Whether to skip the internal rate limiter
     * @requires `SavedMessages`, `DirectMessage`, `Group`, `TextChannel`
     */
    ack(message, skipRateLimiter) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            const lastMessageId = (_b = (_a = (typeof message === "string" ? message : message === null || message === void 0 ? void 0 : message.id)) !== null && _a !== void 0 ? _a : this.lastMessageId) !== null && _b !== void 0 ? _b : (0, ulid_1.ulid)();
            const unreads = __classPrivateFieldGet(this, _Channel_collection, "f").client.channelUnreads;
            const channelUnread = unreads.get(this.id);
            if (channelUnread) {
                unreads.updateUnderlyingObject(this.id, {
                    lastMessageId,
                });
                if (channelUnread.messageMentionIds.size) {
                    channelUnread.messageMentionIds.clear();
                }
            }
            /**
             * Send the actual acknowledgement request
             */
            const performAck = () => {
                __classPrivateFieldSet(this, _Channel_ackLimit, undefined, "f");
                __classPrivateFieldGet(this, _Channel_collection, "f").client.api.put(`/channels/${this.id}/ack/${lastMessageId}`);
            };
            if (skipRateLimiter)
                return performAck();
            clearTimeout(__classPrivateFieldGet(this, _Channel_ackTimeout, "f"));
            if (__classPrivateFieldGet(this, _Channel_ackLimit, "f") && +new Date() > __classPrivateFieldGet(this, _Channel_ackLimit, "f")) {
                performAck();
            }
            // We need to use setTimeout here for both Node.js and browser.
            __classPrivateFieldSet(this, _Channel_ackTimeout, setTimeout(performAck, 5000), "f");
            if (!__classPrivateFieldGet(this, _Channel_ackLimit, "f")) {
                __classPrivateFieldSet(this, _Channel_ackLimit, +new Date() + 15e3, "f");
            }
        });
    }
    /**
     * Set role permissions
     * @param role_id Role Id, set to 'default' to affect all users
     * @param permissions Permission value
     * @requires `Group`, `TextChannel`, `VoiceChannel`
     */
    setPermissions(role_id = "default", permissions) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield __classPrivateFieldGet(this, _Channel_collection, "f").client.api.put(`/channels/${this.id}/permissions/${role_id}`, { permissions });
        });
    }
    /**
     * Start typing in this channel
     * @requires `DirectMessage`, `Group`, `TextChannel`
     */
    startTyping() {
        __classPrivateFieldGet(this, _Channel_collection, "f").client.events.send({
            type: "BeginTyping",
            channel: this.id,
        });
    }
    /**
     * Stop typing in this channel
     * @requires `DirectMessage`, `Group`, `TextChannel`
     */
    stopTyping() {
        __classPrivateFieldGet(this, _Channel_collection, "f").client.events.send({
            type: "EndTyping",
            channel: this.id,
        });
    }
}
exports.Channel = Channel;
_Channel_collection = new WeakMap(), _Channel_ackTimeout = new WeakMap(), _Channel_ackLimit = new WeakMap();
