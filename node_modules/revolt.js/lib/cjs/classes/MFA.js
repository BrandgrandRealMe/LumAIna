"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _MFA_client, _MFA_store, _MFATicket_instances, _MFATicket_client, _MFATicket_ticket, _MFATicket_mutate, _MFATicket_used, _MFATicket_consume;
Object.defineProperty(exports, "__esModule", { value: true });
exports.MFATicket = exports.MFA = void 0;
const store_1 = require("solid-js/store");
/**
 * Multi-Factor Authentication
 */
class MFA {
    /**
     * Construct MFA helper
     * @param client Client
     * @param state State
     */
    constructor(client, state) {
        _MFA_client.set(this, void 0);
        _MFA_store.set(this, void 0);
        __classPrivateFieldSet(this, _MFA_client, client, "f");
        __classPrivateFieldSet(this, _MFA_store, (0, store_1.createStore)(state), "f");
    }
    /**
     * Whether authenticator app is enabled
     */
    get authenticatorEnabled() {
        return __classPrivateFieldGet(this, _MFA_store, "f")[0].totp_mfa;
    }
    /**
     * Whether recovery codes are enabled
     */
    get recoveryEnabled() {
        return __classPrivateFieldGet(this, _MFA_store, "f")[0].recovery_active;
    }
    /**
     * Available MFA methods for generating tickets
     */
    get availableMethods() {
        return this.authenticatorEnabled
            ? this.recoveryEnabled
                ? ["Totp", "Recovery"]
                : ["Totp"]
            : ["Password"];
    }
    /**
     * Create an MFA ticket
     * @param params
     * @returns Token
     */
    createTicket(params) {
        return __classPrivateFieldGet(this, _MFA_client, "f").api
            .put("/auth/mfa/ticket", params)
            .then((ticket) => new MFATicket(__classPrivateFieldGet(this, _MFA_client, "f"), ticket, __classPrivateFieldGet(this, _MFA_store, "f")[1]));
    }
    /**
     * Enable authenticator using token generated from secret found earlier
     * @param token Token
     */
    enableAuthenticator(token) {
        return __awaiter(this, void 0, void 0, function* () {
            yield __classPrivateFieldGet(this, _MFA_client, "f").api.put("/auth/mfa/totp", { totp_code: token });
            __classPrivateFieldGet(this, _MFA_store, "f")[1]("totp_mfa", true);
        });
    }
}
exports.MFA = MFA;
_MFA_client = new WeakMap(), _MFA_store = new WeakMap();
/**
 * MFA Ticket
 */
class MFATicket {
    /**
     * Construct MFA Ticket
     * @param client Client
     * @param ticket Ticket
     * @param mutate Mutate the store
     */
    constructor(client, ticket, mutate) {
        _MFATicket_instances.add(this);
        _MFATicket_client.set(this, void 0);
        _MFATicket_ticket.set(this, void 0);
        _MFATicket_mutate.set(this, void 0);
        _MFATicket_used.set(this, false);
        __classPrivateFieldSet(this, _MFATicket_client, client, "f");
        __classPrivateFieldSet(this, _MFATicket_ticket, ticket, "f");
        __classPrivateFieldSet(this, _MFATicket_mutate, mutate, "f");
    }
    /**
     * Token
     */
    get token() {
        return __classPrivateFieldGet(this, _MFATicket_ticket, "f").token;
    }
    /**
     * Fetch recovery codes
     * @returns List of codes
     */
    fetchRecoveryCodes() {
        __classPrivateFieldGet(this, _MFATicket_instances, "m", _MFATicket_consume).call(this);
        return __classPrivateFieldGet(this, _MFATicket_client, "f").api.post("/auth/mfa/recovery", undefined, {
            headers: {
                "X-MFA-Ticket": this.token,
            },
        });
    }
    /**
     * Generate new set of recovery codes
     * @returns List of codes
     */
    generateRecoveryCodes() {
        return __awaiter(this, void 0, void 0, function* () {
            __classPrivateFieldGet(this, _MFATicket_instances, "m", _MFATicket_consume).call(this);
            const codes = yield __classPrivateFieldGet(this, _MFATicket_client, "f").api.patch("/auth/mfa/recovery", undefined, {
                headers: {
                    "X-MFA-Ticket": this.token,
                },
            });
            __classPrivateFieldGet(this, _MFATicket_mutate, "f").call(this, "recovery_active", true);
            return codes;
        });
    }
    /**
     * Generate new authenticator secret
     * @returns Secret
     */
    generateAuthenticatorSecret() {
        __classPrivateFieldGet(this, _MFATicket_instances, "m", _MFATicket_consume).call(this);
        return __classPrivateFieldGet(this, _MFATicket_client, "f").api
            .post("/auth/mfa/totp", undefined, {
            headers: {
                "X-MFA-Ticket": this.token,
            },
        })
            .then((response) => response.secret);
    }
    /**
     * Disable authenticator
     */
    disableAuthenticator() {
        return __awaiter(this, void 0, void 0, function* () {
            __classPrivateFieldGet(this, _MFATicket_instances, "m", _MFATicket_consume).call(this);
            yield __classPrivateFieldGet(this, _MFATicket_client, "f").api.delete("/auth/mfa/totp", undefined, {
                headers: {
                    "X-MFA-Ticket": this.token,
                },
            });
            __classPrivateFieldGet(this, _MFATicket_mutate, "f").call(this, "totp_mfa", false);
        });
    }
    /**
     * Disable account
     */
    disableAccount() {
        __classPrivateFieldGet(this, _MFATicket_instances, "m", _MFATicket_consume).call(this);
        return __classPrivateFieldGet(this, _MFATicket_client, "f").api.post("/auth/account/disable", undefined, {
            headers: {
                "X-MFA-Ticket": this.token,
            },
        });
    }
    /**
     * Delete account
     */
    deleteAccount() {
        __classPrivateFieldGet(this, _MFATicket_instances, "m", _MFATicket_consume).call(this);
        return __classPrivateFieldGet(this, _MFATicket_client, "f").api.post("/auth/account/delete", undefined, {
            headers: {
                "X-MFA-Ticket": this.token,
            },
        });
    }
}
exports.MFATicket = MFATicket;
_MFATicket_client = new WeakMap(), _MFATicket_ticket = new WeakMap(), _MFATicket_mutate = new WeakMap(), _MFATicket_used = new WeakMap(), _MFATicket_instances = new WeakSet(), _MFATicket_consume = function _MFATicket_consume() {
    if (__classPrivateFieldGet(this, _MFATicket_used, "f"))
        throw "Already used this ticket!";
    __classPrivateFieldSet(this, _MFATicket_used, true, "f");
};
