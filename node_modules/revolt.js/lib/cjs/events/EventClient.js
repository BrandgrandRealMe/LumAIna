"use strict";
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _EventClient_protocolVersion, _EventClient_transportFormat, _EventClient_setPing, _EventClient_setStateSetter, _EventClient_socket, _EventClient_heartbeatIntervalReference, _EventClient_pongTimeoutReference;
Object.defineProperty(exports, "__esModule", { value: true });
exports.EventClient = exports.ConnectionState = void 0;
const solid_js_1 = require("solid-js");
const eventemitter3_1 = __importDefault(require("eventemitter3"));
const isomorphic_ws_1 = __importDefault(require("isomorphic-ws"));
/**
 * All possible event client states.
 */
var ConnectionState;
(function (ConnectionState) {
    ConnectionState[ConnectionState["Idle"] = 0] = "Idle";
    ConnectionState[ConnectionState["Connecting"] = 1] = "Connecting";
    ConnectionState[ConnectionState["Connected"] = 2] = "Connected";
    ConnectionState[ConnectionState["Disconnected"] = 3] = "Disconnected";
})(ConnectionState = exports.ConnectionState || (exports.ConnectionState = {}));
/**
 * Simple wrapper around the Revolt websocket service.
 */
class EventClient extends eventemitter3_1.default {
    /**
     * Create a new event client.
     * @param protocolVersion Target protocol version
     * @param transportFormat Communication format
     * @param options Configuration options
     */
    constructor(protocolVersion, transportFormat = "json", options) {
        super();
        _EventClient_protocolVersion.set(this, void 0);
        _EventClient_transportFormat.set(this, void 0);
        _EventClient_setPing.set(this, void 0);
        _EventClient_setStateSetter.set(this, void 0);
        _EventClient_socket.set(this, void 0);
        _EventClient_heartbeatIntervalReference.set(this, void 0);
        _EventClient_pongTimeoutReference.set(this, void 0);
        __classPrivateFieldSet(this, _EventClient_protocolVersion, protocolVersion, "f");
        __classPrivateFieldSet(this, _EventClient_transportFormat, transportFormat, "f");
        this.options = Object.assign({ heartbeatInterval: 30, pongTimeout: 10, debug: false }, options);
        const [state, setState] = (0, solid_js_1.createSignal)(ConnectionState.Idle);
        this.state = state;
        __classPrivateFieldSet(this, _EventClient_setStateSetter, setState, "f");
        const [ping, setPing] = (0, solid_js_1.createSignal)(-1);
        this.ping = ping;
        __classPrivateFieldSet(this, _EventClient_setPing, setPing, "f");
        this.disconnect = this.disconnect.bind(this);
    }
    /**
     * Set the current state
     * @param state state
     */
    setState(state) {
        __classPrivateFieldGet(this, _EventClient_setStateSetter, "f").call(this, state);
        this.emit("state", state);
    }
    /**
     * Connect to the websocket service.
     * @param uri WebSocket URI
     * @param token Authentication token
     */
    connect(uri, token) {
        this.disconnect();
        this.setState(ConnectionState.Connecting);
        __classPrivateFieldSet(this, _EventClient_socket, new isomorphic_ws_1.default(`${uri}?version=${__classPrivateFieldGet(this, _EventClient_protocolVersion, "f")}&format=${__classPrivateFieldGet(this, _EventClient_transportFormat, "f")}&token=${token}`), "f");
        __classPrivateFieldGet(this, _EventClient_socket, "f").onopen = () => {
            __classPrivateFieldSet(this, _EventClient_heartbeatIntervalReference, setInterval(() => {
                this.send({ type: "Ping", data: +new Date() });
                __classPrivateFieldSet(this, _EventClient_pongTimeoutReference, setTimeout(() => this.disconnect(), this.options.pongTimeout * 1e3), "f");
            }, this.options.heartbeatInterval * 1e3), "f");
        };
        __classPrivateFieldGet(this, _EventClient_socket, "f").onerror = (error) => {
            this.emit("error", error);
        };
        __classPrivateFieldGet(this, _EventClient_socket, "f").onmessage = (event) => {
            if (__classPrivateFieldGet(this, _EventClient_transportFormat, "f") === "json") {
                if (typeof event.data === "string") {
                    this.handle(JSON.parse(event.data));
                }
            }
        };
        let closed = false;
        __classPrivateFieldGet(this, _EventClient_socket, "f").onclose = () => {
            if (closed)
                return;
            closed = true;
            this.disconnect();
        };
    }
    /**
     * Disconnect the websocket client.
     */
    disconnect() {
        if (!__classPrivateFieldGet(this, _EventClient_socket, "f"))
            return;
        clearInterval(__classPrivateFieldGet(this, _EventClient_heartbeatIntervalReference, "f"));
        const socket = __classPrivateFieldGet(this, _EventClient_socket, "f");
        __classPrivateFieldSet(this, _EventClient_socket, undefined, "f");
        socket.close();
        this.setState(ConnectionState.Disconnected);
    }
    /**
     * Send an event to the server.
     * @param event Event
     */
    send(event) {
        this.options.debug && console.debug("[C->S]", event);
        if (!__classPrivateFieldGet(this, _EventClient_socket, "f"))
            throw "Socket closed, trying to send.";
        __classPrivateFieldGet(this, _EventClient_socket, "f").send(JSON.stringify(event));
    }
    /**
     * Handle events intended for client before passing them along.
     * @param event Event
     */
    handle(event) {
        this.options.debug && console.debug("[S->C]", event);
        switch (event.type) {
            case "Ping":
                this.send({
                    type: "Pong",
                    data: event.data,
                });
                return;
            case "Pong":
                clearTimeout(__classPrivateFieldGet(this, _EventClient_pongTimeoutReference, "f"));
                __classPrivateFieldGet(this, _EventClient_setPing, "f").call(this, +new Date() - event.data);
                this.options.debug && console.debug(`[ping] ${this.ping()}ms`);
                return;
            case "Error":
                this.emit("error", event);
                this.disconnect();
                return;
        }
        switch (this.state()) {
            case ConnectionState.Connecting:
                if (event.type === "Authenticated") {
                    // no-op
                }
                else if (event.type === "Ready") {
                    this.emit("event", event);
                    this.setState(ConnectionState.Connected);
                }
                else {
                    throw `Unreachable code. Received ${event.type} in Connecting state.`;
                }
                break;
            case ConnectionState.Connected:
                if (event.type === "Authenticated" || event.type === "Ready") {
                    throw `Unreachable code. Received ${event.type} in Connected state.`;
                }
                else {
                    this.emit("event", event);
                }
                break;
            default:
                throw `Unreachable code. Received ${event.type} in state ${this.state()}.`;
        }
    }
}
exports.EventClient = EventClient;
_EventClient_protocolVersion = new WeakMap(), _EventClient_transportFormat = new WeakMap(), _EventClient_setPing = new WeakMap(), _EventClient_setStateSetter = new WeakMap(), _EventClient_socket = new WeakMap(), _EventClient_heartbeatIntervalReference = new WeakMap(), _EventClient_pongTimeoutReference = new WeakMap();
