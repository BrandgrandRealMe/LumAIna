"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.handleEvent = void 0;
const solid_js_1 = require("solid-js");
const set_1 = require("@solid-primitives/set");
/**
 * Handle an event for the Client
 * @param client Client
 * @param event Event
 * @param setReady Signal state change
 */
function handleEvent(client, event, setReady) {
    var _a, _b, _c, _d, _e, _f;
    return __awaiter(this, void 0, void 0, function* () {
        switch (event.type) {
            case "Bulk": {
                for (const item of event.v) {
                    handleEvent(client, item, setReady);
                }
                break;
            }
            case "Ready": {
                (0, solid_js_1.batch)(() => {
                    for (const user of event.users) {
                        const u = client.users.getOrCreate(user._id, user);
                        if (u.relationship === "User") {
                            client.user = u;
                        }
                    }
                    for (const server of event.servers) {
                        client.servers.getOrCreate(server._id, server);
                    }
                    for (const member of event.members) {
                        client.serverMembers.getOrCreate(member._id, member);
                    }
                    for (const channel of event.channels) {
                        client.channels.getOrCreate(channel._id, channel);
                    }
                    for (const emoji of event.emojis) {
                        client.emojis.getOrCreate(emoji._id, emoji);
                    }
                });
                if (client.options.syncUnreads) {
                    yield client.channelUnreads.sync();
                }
                setReady(true);
                client.emit("ready");
                break;
            }
            case "Message": {
                if (!client.messages.has(event._id)) {
                    // TODO: this should not be necessary in future protocols:
                    if (event.author && !event.webhook && client.options.eagerFetching) {
                        yield client.users.fetch(event.author);
                        const serverId = (_a = client.channels.get(event.channel)) === null || _a === void 0 ? void 0 : _a.serverId;
                        if (serverId)
                            yield client.serverMembers.fetch(serverId, event.author);
                    }
                    client.messages.getOrCreate(event._id, event, true);
                }
                break;
            }
            case "MessageUpdate": {
                const message = client.messages.getOrPartial(event.id);
                if (message) {
                    const previousMessage = Object.assign({}, client.messages.getUnderlyingObject(event.id));
                    client.messages.updateUnderlyingObject(event.id, Object.assign(Object.assign({}, event.data), { editedAt: new Date() }));
                    client.emit("messageUpdate", message, previousMessage);
                }
                break;
            }
            case "MessageAppend": {
                const message = client.messages.getOrPartial(event.id);
                if (message) {
                    const previousMessage = Object.assign({}, client.messages.getUnderlyingObject(event.id));
                    client.messages.updateUnderlyingObject(event.id, "embeds", (embeds) => { var _a; return [...(embeds !== null && embeds !== void 0 ? embeds : []), (_a = event.append.embeds) !== null && _a !== void 0 ? _a : []]; });
                    client.emit("messageUpdate", message, previousMessage);
                }
                break;
            }
            case "MessageDelete": {
                if (client.messages.getOrPartial(event.id)) {
                    const message = client.messages.getUnderlyingObject(event.id);
                    client.emit("messageDelete", message);
                    client.messages.delete(event.id);
                }
                break;
            }
            case "BulkMessageDelete": {
                (0, solid_js_1.batch)(() => client.emit("messageDeleteBulk", event.ids
                    .map((id) => {
                    if (client.messages.has(id)) {
                        const message = client.messages.getUnderlyingObject(id);
                        client.messages.delete(id);
                        return message;
                    }
                    return undefined;
                })
                    .filter((x) => x), client.channels.get(event.channel)));
                break;
            }
            case "MessageReact": {
                const message = client.messages.getOrPartial(event.id);
                if (message) {
                    const reactions = message.reactions;
                    const set = reactions.get(event.emoji_id);
                    if (set) {
                        if (set.has(event.user_id))
                            return;
                        set.add(event.user_id);
                    }
                    else {
                        reactions.set(event.emoji_id, new set_1.ReactiveSet([event.user_id]));
                    }
                    client.emit("messageReactionAdd", message, event.user_id, event.emoji_id);
                }
                break;
            }
            case "MessageUnreact": {
                const message = client.messages.getOrPartial(event.id);
                if (message) {
                    const set = message.reactions.get(event.emoji_id);
                    if (set === null || set === void 0 ? void 0 : set.has(event.user_id)) {
                        set.delete(event.user_id);
                    }
                    else if (!client.messages.isPartial(event.id)) {
                        return;
                    }
                    client.emit("messageReactionRemove", message, event.user_id, event.emoji_id);
                }
                break;
            }
            case "MessageRemoveReaction": {
                const message = client.messages.getOrPartial(event.id);
                if (message) {
                    const reactions = message.reactions;
                    if (reactions.has(event.emoji_id)) {
                        reactions.delete(event.emoji_id);
                    }
                    else if (!client.messages.isPartial(event.id)) {
                        return;
                    }
                    client.emit("messageReactionRemoveEmoji", message, event.emoji_id);
                }
                break;
            }
            case "ChannelCreate": {
                if (!client.channels.has(event._id)) {
                    client.channels.getOrCreate(event._id, event, true);
                }
                break;
            }
            case "ChannelUpdate": {
                const channel = client.channels.getOrPartial(event.id);
                if (channel) {
                    const previousChannel = Object.assign({}, client.channels.getUnderlyingObject(event.id));
                    const changes = Object.assign({}, event.data);
                    if (event.clear) {
                        for (const remove of event.clear) {
                            switch (remove) {
                                case "Description":
                                    changes["description"] = undefined;
                                    break;
                                case "DefaultPermissions":
                                    changes["default_permissions"] = undefined;
                                    break;
                                case "Icon":
                                    changes["icon"] = undefined;
                                    break;
                            }
                        }
                    }
                    client.channels.updateUnderlyingObject(event.id, changes);
                    client.emit("channelUpdate", channel, previousChannel);
                }
                break;
            }
            case "ChannelDelete": {
                if (client.channels.getOrPartial(event.id)) {
                    const channel = client.channels.getUnderlyingObject(event.id);
                    client.emit("channelDelete", channel);
                    client.channels.delete(event.id);
                }
                break;
            }
            case "ChannelGroupJoin": {
                const channel = client.channels.getOrPartial(event.id);
                if (channel) {
                    if (!channel.recipientIds.has(event.user)) {
                        channel.recipientIds.add(event.user);
                    }
                    else if (!client.channels.isPartial(event.id)) {
                        return;
                    }
                    client.emit("channelGroupJoin", channel, yield client.users.fetch(event.user));
                }
                break;
            }
            case "ChannelGroupLeave": {
                const channel = client.channels.getOrPartial(event.id);
                if (channel) {
                    if (channel.recipientIds.has(event.user)) {
                        channel.recipientIds.delete(event.user);
                    }
                    else if (!client.channels.isPartial(event.id)) {
                        return;
                    }
                    client.emit("channelGroupLeave", channel, client.users.getOrPartial(event.user));
                }
                break;
            }
            case "ChannelStartTyping": {
                const channel = client.channels.getOrPartial(event.id);
                if (channel) {
                    if (!channel.typingIds.has(event.user)) {
                        channel.typingIds.add(event.user);
                    }
                    else if (!client.channels.isPartial(event.id)) {
                        return;
                    }
                    client.emit("channelStartTyping", channel, client.users.getOrPartial(event.user));
                }
                break;
            }
            case "ChannelStopTyping": {
                const channel = client.channels.getOrPartial(event.id);
                if (channel) {
                    if (channel.typingIds.has(event.user)) {
                        channel.typingIds.delete(event.user);
                    }
                    else if (!client.channels.isPartial(event.id)) {
                        return;
                    }
                    client.emit("channelStopTyping", channel, client.users.getOrPartial(event.user));
                }
                break;
            }
            case "ChannelAck": {
                const channel = client.channels.getOrPartial(event.id);
                if (channel) {
                    client.emit("channelAcknowledged", channel, event.message_id);
                }
                break;
            }
            case "ServerCreate": {
                if (!client.servers.has(event.server._id)) {
                    (0, solid_js_1.batch)(() => {
                        for (const channel of event.channels) {
                            client.channels.getOrCreate(channel._id, channel);
                        }
                        client.servers.getOrCreate(event.server._id, event.server, true);
                    });
                }
                break;
            }
            case "ServerUpdate": {
                const server = client.servers.getOrPartial(event.id);
                if (server) {
                    const previousServer = Object.assign({}, client.servers.getUnderlyingObject(event.id));
                    const changes = Object.assign({}, event.data);
                    if (event.clear) {
                        for (const remove of event.clear) {
                            switch (remove) {
                                case "Banner":
                                    changes["banner"] = undefined;
                                    break;
                                case "Categories":
                                    changes["categories"] = undefined;
                                    break;
                                case "SystemMessages":
                                    changes["system_messages"] = undefined;
                                    break;
                                case "Description":
                                    changes["description"] = undefined;
                                    break;
                                case "Icon":
                                    changes["icon"] = undefined;
                                    break;
                            }
                        }
                    }
                    client.servers.updateUnderlyingObject(event.id, changes);
                    client.emit("serverUpdate", server, previousServer);
                }
                break;
            }
            case "ServerDelete": {
                if (client.servers.getOrPartial(event.id)) {
                    (0, solid_js_1.batch)(() => {
                        const server = client.servers.getUnderlyingObject(event.id);
                        client.emit("serverDelete", server);
                        client.servers.delete(event.id);
                        for (const channel of server.channelIds) {
                            client.channels.delete(channel);
                        }
                    });
                }
                break;
            }
            case "ServerRoleUpdate": {
                const server = client.servers.getOrPartial(event.id);
                if (server) {
                    const role = (_b = server.roles.get(event.role_id)) !== null && _b !== void 0 ? _b : {};
                    server.roles.set(event.role_id, Object.assign(Object.assign({}, role), event.data));
                    client.emit("serverRoleUpdate", server, event.role_id, role);
                }
                break;
            }
            case "ServerRoleDelete": {
                const server = client.servers.getOrPartial(event.id);
                if (server) {
                    let role = {};
                    const roles = server.roles;
                    if (roles.has(event.role_id)) {
                        role = roles.get(event.role_id);
                        roles.delete(event.role_id);
                    }
                    else if (!client.servers.isPartial(event.id)) {
                        return;
                    }
                    client.emit("serverRoleDelete", server, event.role_id, role);
                }
                break;
            }
            case "ServerMemberJoin": {
                const id = {
                    server: event.id,
                    user: event.user,
                };
                if (!client.serverMembers.hasByKey(id)) {
                    client.emit("serverMemberJoin", client.serverMembers.getOrCreate(id, {
                        _id: id,
                        joined_at: new Date().toUTCString(),
                    }));
                }
                break;
            }
            case "ServerMemberUpdate": {
                const member = client.serverMembers.getOrPartial(event.id);
                if (member) {
                    const previousMember = Object.assign({}, client.serverMembers.getUnderlyingObject(event.id.server + event.id.user));
                    const changes = Object.assign({}, event.data);
                    if (event.clear) {
                        for (const remove of event.clear) {
                            switch (remove) {
                                case "Nickname":
                                    changes["nickname"] = undefined;
                                    break;
                                case "Avatar":
                                    changes["avatar"] = undefined;
                                    break;
                                case "Roles":
                                    changes["roles"] = undefined;
                                    break;
                                case "Timeout":
                                    changes["timeout"] = undefined;
                                    break;
                            }
                        }
                    }
                    client.serverMembers.updateUnderlyingObject(event.id.server + event.id.user, changes);
                    client.emit("serverMemberUpdate", member, previousMember);
                }
                break;
            }
            case "ServerMemberLeave": {
                const id = {
                    server: event.id,
                    user: event.user,
                };
                if (client.serverMembers.getOrPartial(id)) {
                    const member = client.serverMembers.getUnderlyingObject(id.server + id.user);
                    client.emit("serverMemberLeave", member);
                    client.serverMembers.delete(id.server + id.user);
                }
                break;
            }
            case "UserUpdate": {
                const user = client.users.getOrPartial(event.id);
                if (user) {
                    const previousUser = Object.assign({}, client.users.getUnderlyingObject(event.id));
                    const changes = Object.assign({}, event.data);
                    if (event.clear) {
                        for (const remove of event.clear) {
                            switch (remove) {
                                case "Avatar":
                                    changes["avatar"] = undefined;
                                    break;
                                case "StatusPresence":
                                    changes["status"] = Object.assign(Object.assign(Object.assign({}, ((_c = previousUser.status) !== null && _c !== void 0 ? _c : {})), ((_d = changes["status"]) !== null && _d !== void 0 ? _d : {})), { presence: undefined });
                                    break;
                                case "StatusText":
                                    changes["status"] = Object.assign(Object.assign(Object.assign({}, ((_e = previousUser.status) !== null && _e !== void 0 ? _e : {})), ((_f = changes["status"]) !== null && _f !== void 0 ? _f : {})), { text: undefined });
                                    break;
                            }
                        }
                    }
                    client.users.updateUnderlyingObject(event.id, changes);
                    client.emit("userUpdate", user, previousUser);
                }
                break;
            }
            case "UserRelationship": {
                handleEvent(client, {
                    type: "UserUpdate",
                    id: event.user._id,
                    data: {
                        relationship: event.user.relationship,
                    },
                }, setReady);
                break;
            }
            case "UserPresence": {
                handleEvent(client, {
                    type: "UserUpdate",
                    id: event.id,
                    data: {
                        online: event.online,
                    },
                }, setReady);
                break;
            }
            case "UserSettingsUpdate": {
                client.emit("userSettingsUpdate", event.id, event.update);
                break;
            }
            case "UserPlatformWipe": {
                (0, solid_js_1.batch)(() => {
                    handleEvent(client, {
                        type: "BulkMessageDelete",
                        channel: "0",
                        ids: client.messages
                            .toList()
                            .filter((message) => message.authorId === event.user_id)
                            .map((message) => message.id),
                    }, setReady);
                    handleEvent(client, {
                        type: "UserUpdate",
                        id: event.user_id,
                        data: {
                            username: `Deleted User`,
                            online: false,
                            flags: event.flags,
                            badges: 0,
                            relationship: "None",
                        },
                        clear: ["Avatar", "StatusPresence", "StatusText"],
                    }, setReady);
                });
                break;
            }
            case "EmojiCreate": {
                if (!client.emojis.has(event._id)) {
                    client.emojis.getOrCreate(event._id, event, true);
                }
                break;
            }
            case "EmojiDelete": {
                if (client.emojis.getOrPartial(event.id)) {
                    const emoji = client.emojis.getUnderlyingObject(event.id);
                    client.emit("emojiDelete", emoji);
                    client.emojis.delete(event.id);
                }
                break;
            }
            case "Auth": {
                // TODO: implement DeleteSession and DeleteAllSessions
                break;
            }
        }
    });
}
exports.handleEvent = handleEvent;
