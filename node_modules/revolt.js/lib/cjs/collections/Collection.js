"use strict";
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _StoreCollection_storage, _StoreCollection_objects;
Object.defineProperty(exports, "__esModule", { value: true });
exports.ClassCollection = exports.StoreCollection = exports.Collection = void 0;
const map_1 = require("@solid-primitives/map");
const ObjectStorage_1 = require("../storage/ObjectStorage");
/**
 * Abstract Collection type
 */
class Collection {
    /**
     * List of values in the map
     * @returns List
     */
    toList() {
        return [...this.values()];
    }
    /**
     * Filter the collection by a given predicate
     * @param predicate Predicate to satisfy
     */
    filter(predicate) {
        const list = [];
        for (const [key, value] of this.entries()) {
            if (predicate(value, key)) {
                list.push(value);
            }
        }
        return list;
    }
    /**
     * Map the collection using a given callback
     * @param cb Callback
     */
    map(cb) {
        const list = [];
        for (const [key, value] of this.entries()) {
            list.push(cb(value, key));
        }
        return list;
    }
    /**
     * Find some value based on a predicate
     * @param predicate Predicate to satisfy
     */
    find(predicate) {
        for (const [key, value] of this.entries()) {
            if (predicate(value, key)) {
                return value;
            }
        }
    }
}
exports.Collection = Collection;
/**
 * Collection backed by a Solid.js Store
 */
class StoreCollection extends Collection {
    /**
     * Construct store backed collection
     */
    constructor() {
        super();
        _StoreCollection_storage.set(this, new ObjectStorage_1.ObjectStorage());
        _StoreCollection_objects.set(this, new map_1.ReactiveMap());
        this.getUnderlyingObject = (key) => { var _a; return (_a = __classPrivateFieldGet(this, _StoreCollection_storage, "f").get(key)) !== null && _a !== void 0 ? _a : {}; };
        this.updateUnderlyingObject = __classPrivateFieldGet(this, _StoreCollection_storage, "f").set;
    }
    /**
     * Get an existing object
     * @param id Id
     * @returns Object
     */
    get(id) {
        return __classPrivateFieldGet(this, _StoreCollection_objects, "f").get(id);
    }
    /**
     * Check whether an id exists in the Collection
     * @param id Id
     * @returns Whether it exists
     */
    has(id) {
        return __classPrivateFieldGet(this, _StoreCollection_objects, "f").has(id);
    }
    /**
     * Delete an object
     * @param id Id
     */
    delete(id) {
        __classPrivateFieldGet(this, _StoreCollection_objects, "f").delete(id);
        this.updateUnderlyingObject(id, undefined);
    }
    /**
     * Create a new instance of an object
     * @param id Id
     * @param type Type
     * @param instance Instance
     * @param context Context
     * @param data Data
     */
    create(id, type, instance, context, data) {
        __classPrivateFieldGet(this, _StoreCollection_storage, "f").hydrate(id, type, context, data);
        __classPrivateFieldGet(this, _StoreCollection_objects, "f").set(id, instance);
    }
    /**
     * Check whether an object is partially defined
     * @param id Id
     * @returns Whether it is a partial
     */
    isPartial(id) {
        return !!this.getUnderlyingObject(id).partial;
    }
    /**
     * Number of stored objects
     * @returns Size
     */
    size() {
        return __classPrivateFieldGet(this, _StoreCollection_objects, "f").size;
    }
    /**
     * Iterable of keys in the map
     * @returns Iterable
     */
    keys() {
        return __classPrivateFieldGet(this, _StoreCollection_objects, "f").keys();
    }
    /**
     * Iterable of values in the map
     * @returns Iterable
     */
    values() {
        return __classPrivateFieldGet(this, _StoreCollection_objects, "f").values();
    }
    /**
     * Iterable of key, value pairs in the map
     * @returns Iterable
     */
    entries() {
        return __classPrivateFieldGet(this, _StoreCollection_objects, "f").entries();
    }
    /**
     * Execute a provided function over each key, value pair in the map
     * @param cb Callback for each pair
     * @returns Iterable
     */
    forEach(cb) {
        return __classPrivateFieldGet(this, _StoreCollection_objects, "f").forEach(cb);
    }
}
exports.StoreCollection = StoreCollection;
_StoreCollection_storage = new WeakMap(), _StoreCollection_objects = new WeakMap();
/**
 * Generic class collection backed by store
 */
class ClassCollection extends StoreCollection {
    /**
     * Create generic class collection
     * @param client Client
     */
    constructor(client) {
        super();
        this.client = client;
    }
}
exports.ClassCollection = ClassCollection;
