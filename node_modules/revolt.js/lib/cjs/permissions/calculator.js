"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.calculatePermission = exports.bitwiseAndEq = void 0;
const long_1 = __importDefault(require("long"));
const __1 = require("..");
const definitions_1 = require("./definitions");
/**
 * Check whether `b` is present in `a`
 * @param a Input A
 * @param b Inputs (OR'd together)
 */
function bitwiseAndEq(a, ...b) {
    const value = b.reduce((prev, cur) => prev.or(cur), long_1.default.fromNumber(0));
    return value.and(a).eq(value);
}
exports.bitwiseAndEq = bitwiseAndEq;
/**
 * Calculate permissions against a given object
 * @param target Target object to check permissions against
 * @param options Additional options to use when calculating
 */
function calculatePermission(client, target, options) {
    var _a, _b, _c, _d, _e, _f;
    const user = (options === null || options === void 0 ? void 0 : options.member) ? options === null || options === void 0 ? void 0 : options.member.user : client.user;
    if (user === null || user === void 0 ? void 0 : user.privileged) {
        return definitions_1.Permission.GrantAllSafe;
    }
    if (target instanceof __1.Server) {
        // 1. Check if owner.
        if (target.ownerId === (user === null || user === void 0 ? void 0 : user.id)) {
            return definitions_1.Permission.GrantAllSafe;
        }
        else {
            // 2. Get ServerMember.
            const member = (_b = (_a = options === null || options === void 0 ? void 0 : options.member) !== null && _a !== void 0 ? _a : client.serverMembers.getByKey({
                user: user.id,
                server: target.id,
            })) !== null && _b !== void 0 ? _b : { roles: null, timeout: null };
            if (!member)
                return 0;
            // 3. Apply allows from default_permissions.
            let perm = long_1.default.fromNumber(target.defaultPermissions);
            // 4. If user has roles, iterate in order.
            if (member.roles && target.roles) {
                // 5. Apply allows and denies from roles.
                const permissions = member.orderedRoles.map((role) => { var _a; return (_a = role.permissions) !== null && _a !== void 0 ? _a : { a: 0, d: 0 }; });
                for (const permission of permissions) {
                    perm = perm.or(permission.a).and(long_1.default.fromNumber(permission.d).not());
                }
            }
            // 5. Revoke permissions if ServerMember is timed out.
            if (member.timeout && member.timeout > new Date()) {
                perm = perm.and(definitions_1.ALLOW_IN_TIMEOUT);
            }
            return perm.toNumber();
        }
    }
    else {
        // 1. Check channel type.
        switch (target.type) {
            case "SavedMessages":
                return definitions_1.Permission.GrantAllSafe;
            case "DirectMessage": {
                // 2. Determine user permissions.
                const user_permissions = ((_c = target.recipient) === null || _c === void 0 ? void 0 : _c.permission) || 0;
                // 3. Check if the user can send messages.
                if (user_permissions & definitions_1.UserPermission.SendMessage) {
                    return definitions_1.DEFAULT_PERMISSION_DIRECT_MESSAGE;
                }
                else {
                    return definitions_1.DEFAULT_PERMISSION_VIEW_ONLY;
                }
            }
            case "Group": {
                // 2. Check if user is owner.
                if (target.ownerId === user.id) {
                    return definitions_1.Permission.GrantAllSafe;
                }
                else {
                    // 3. Pull out group permissions.
                    return (_d = target.permissions) !== null && _d !== void 0 ? _d : definitions_1.DEFAULT_PERMISSION_DIRECT_MESSAGE;
                }
            }
            case "TextChannel":
            case "VoiceChannel": {
                // 2. Get server.
                const server = target.server;
                if (typeof server === "undefined")
                    return 0;
                // 3. If server owner, just grant all permissions.
                if (server.ownerId === (user === null || user === void 0 ? void 0 : user.id)) {
                    return definitions_1.Permission.GrantAllSafe;
                }
                else {
                    // 4. Get ServerMember.
                    const member = (_f = (_e = options === null || options === void 0 ? void 0 : options.member) !== null && _e !== void 0 ? _e : client.serverMembers.getByKey({
                        user: user.id,
                        server: server.id,
                    })) !== null && _f !== void 0 ? _f : { roles: null, timeout: null };
                    if (!member)
                        return 0;
                    // 5. Calculate server base permissions.
                    let perm = long_1.default.fromNumber(calculatePermission(client, server, options));
                    // 6. Apply default allows and denies for channel.
                    if (target.defaultPermissions) {
                        perm = perm
                            .or(target.defaultPermissions.a)
                            .and(long_1.default.fromNumber(target.defaultPermissions.d).not());
                    }
                    // 7. If user has roles, iterate in order.
                    if (member.roles && target.rolePermissions && server.roles) {
                        // 5. Apply allows and denies from roles.
                        const roles = member.orderedRoles.map(({ id }) => id);
                        for (const id of roles) {
                            const override = target.rolePermissions[id];
                            if (override) {
                                perm = perm
                                    .or(override.a)
                                    .and(long_1.default.fromNumber(override.d).not());
                            }
                        }
                    }
                    // 8. Revoke permissions if ServerMember is timed out.
                    if (member.timeout && member.timeout > new Date()) {
                        perm = perm.and(definitions_1.ALLOW_IN_TIMEOUT);
                    }
                    return perm.toNumber();
                }
            }
        }
    }
}
exports.calculatePermission = calculatePermission;
