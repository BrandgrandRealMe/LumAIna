"use strict";
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _Client_protocolVersion, _Client_transportFormat, _Client_heartbeatInterval, _Client_pongTimeout, _Client_state, _Client_setStateSetter, _Client_socket, _Client_heartbeatIntervalReference, _Client_pongTimeoutReference;
Object.defineProperty(exports, "__esModule", { value: true });
exports.createEventClient = exports.ConnectionState = void 0;
const solid_js_1 = require("solid-js");
const events_1 = __importDefault(require("events"));
const isomorphic_ws_1 = __importDefault(require("isomorphic-ws"));
/**
 * All possible event client states.
 */
var ConnectionState;
(function (ConnectionState) {
    ConnectionState[ConnectionState["Idle"] = 0] = "Idle";
    ConnectionState[ConnectionState["Connecting"] = 1] = "Connecting";
    ConnectionState[ConnectionState["Connected"] = 2] = "Connected";
    ConnectionState[ConnectionState["Disconnected"] = 3] = "Disconnected";
})(ConnectionState = exports.ConnectionState || (exports.ConnectionState = {}));
/**
 * Simple wrapper around the Revolt websocket service.
 */
class Client extends events_1.default {
    /**
     * Create a new event client.
     * @param protocolVersion Target protocol version
     * @param transportFormat Communication format
     * @param heartbeatInterval Interval in seconds to send ping
     * @param pongTimeout Time in seconds until heartbeat times out
     */
    constructor(protocolVersion, transportFormat = "json", heartbeatInterval = 30, pongTimeout = 10) {
        super();
        _Client_protocolVersion.set(this, void 0);
        _Client_transportFormat.set(this, void 0);
        _Client_heartbeatInterval.set(this, void 0);
        _Client_pongTimeout.set(this, void 0);
        _Client_state.set(this, void 0);
        _Client_setStateSetter.set(this, void 0);
        _Client_socket.set(this, void 0);
        _Client_heartbeatIntervalReference.set(this, void 0);
        _Client_pongTimeoutReference.set(this, void 0);
        __classPrivateFieldSet(this, _Client_protocolVersion, protocolVersion, "f");
        __classPrivateFieldSet(this, _Client_transportFormat, transportFormat, "f");
        __classPrivateFieldSet(this, _Client_heartbeatInterval, heartbeatInterval, "f");
        __classPrivateFieldSet(this, _Client_pongTimeout, pongTimeout, "f");
        const [state, setState] = (0, solid_js_1.createSignal)(ConnectionState.Idle);
        __classPrivateFieldSet(this, _Client_state, state, "f");
        __classPrivateFieldSet(this, _Client_setStateSetter, setState, "f");
        this.disconnect = this.disconnect.bind(this);
    }
    /**
     * Set the current state
     * @param state state
     */
    setState(state) {
        __classPrivateFieldGet(this, _Client_setStateSetter, "f").call(this, state);
        this.emit("state", state);
        // TODO: debug weird state changes
    }
    /**
     * Connect to the websocket service.
     * @param uri WebSocket URI
     * @param token Authentication token
     */
    connect(uri, token) {
        this.disconnect();
        this.setState(ConnectionState.Connecting);
        __classPrivateFieldSet(this, _Client_socket, new isomorphic_ws_1.default(`${uri}?version=${__classPrivateFieldGet(this, _Client_protocolVersion, "f")}&format=${__classPrivateFieldGet(this, _Client_transportFormat, "f")}&token=${token}`), "f");
        __classPrivateFieldGet(this, _Client_socket, "f").onopen = () => {
            __classPrivateFieldSet(this, _Client_heartbeatIntervalReference, setInterval(() => (__classPrivateFieldSet(this, _Client_pongTimeoutReference, setTimeout(this.disconnect, __classPrivateFieldGet(this, _Client_pongTimeout, "f") * 1e3), "f")), __classPrivateFieldGet(this, _Client_heartbeatInterval, "f") & 1e3), "f");
        };
        __classPrivateFieldGet(this, _Client_socket, "f").onerror = (error) => {
            this.emit("error", error);
        };
        __classPrivateFieldGet(this, _Client_socket, "f").onmessage = (event) => {
            if (__classPrivateFieldGet(this, _Client_transportFormat, "f") === "json") {
                if (typeof event.data === "string") {
                    this.handle(JSON.parse(event.data));
                }
            }
        };
        __classPrivateFieldGet(this, _Client_socket, "f").onclose = () => {
            clearInterval(__classPrivateFieldGet(this, _Client_heartbeatIntervalReference, "f"));
            this.setState(ConnectionState.Disconnected);
        };
    }
    /**
     * Disconnect the websocket client.
     */
    disconnect() {
        if (!__classPrivateFieldGet(this, _Client_socket, "f"))
            return;
        __classPrivateFieldGet(this, _Client_socket, "f").close();
    }
    /**
     * Send an event to the server.
     * @param event Event
     */
    send(event) {
        console.info(event);
    }
    /**
     * Handle events intended for client before passing them along.
     * @param event Event
     */
    handle(event) {
        switch (event.type) {
            case "Ping":
                this.send({
                    type: "Pong",
                    data: event.data,
                });
                return;
            case "Pong":
                clearTimeout(__classPrivateFieldGet(this, _Client_pongTimeoutReference, "f"));
                return;
            case "Error":
                this.emit("error", event);
                this.disconnect();
                return;
        }
        switch (__classPrivateFieldGet(this, _Client_state, "f").call(this)) {
            case ConnectionState.Connecting:
                if (event.type === "Authenticated") {
                    // no-op
                }
                else if (event.type === "Ready") {
                    this.emit("event", event);
                    this.setState(ConnectionState.Connected);
                }
                else {
                    console.error("WE ARE IN WRONG STATE");
                }
                break;
            case ConnectionState.Connected:
                if (event.type === "Authenticated" || event.type === "Ready") {
                    throw `Unreachable code. Received ${event.type} in Connected state.`;
                }
                else {
                    this.emit("event", event);
                }
                break;
            default:
                throw `Unreachable code. Received ${event.type} in state ${__classPrivateFieldGet(this, _Client_state, "f").call(this)}.`;
        }
    }
}
_Client_protocolVersion = new WeakMap(), _Client_transportFormat = new WeakMap(), _Client_heartbeatInterval = new WeakMap(), _Client_pongTimeout = new WeakMap(), _Client_state = new WeakMap(), _Client_setStateSetter = new WeakMap(), _Client_socket = new WeakMap(), _Client_heartbeatIntervalReference = new WeakMap(), _Client_pongTimeoutReference = new WeakMap();
/**
 * Create a new event client.
 * @param protocolVersion Target protocol version
 * @param transportFormat Communication format
 * @param heartbeatInterval Interval in seconds to send ping
 * @param pongTimeout Time in seconds until heartbeat times out
 */
function createEventClient(protocolVersion, transportFormat, heartbeatInterval, pongTimeout) {
    return new Client(protocolVersion, transportFormat, heartbeatInterval, pongTimeout);
}
exports.createEventClient = createEventClient;
