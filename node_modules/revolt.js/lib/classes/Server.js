"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
Object.defineProperty(exports, "__esModule", { value: true });
const ulid_1 = require("ulid");
const ObjectStorage_1 = require("../storage/ObjectStorage");
exports.default = (client) => { var _a, _Server_storage, _Server_objects; return _a = 
/**
 * Server Class
 */
class Server {
        /**
         * Get an existing Server
         * @param id Server ID
         * @returns Server
         */
        static get(id) {
            return __classPrivateFieldGet(Server, _a, "f", _Server_objects)[id];
        }
        /**
         * Fetch server by ID
         * @param id ID
         * @returns Server
         */
        static fetch(id) {
            return __awaiter(this, void 0, void 0, function* () {
                const server = Server.get(id);
                if (server)
                    return server;
                const data = yield client.api.get(`/servers/${id}`);
                return new Server(id, data);
            });
        }
        /**
         * Construct Server
         * @param id Server Id
         */
        constructor(id, data) {
            __classPrivateFieldGet(Server, _a, "f", _Server_storage).hydrate(id, "server", data);
            __classPrivateFieldGet(Server, _a, "f", _Server_objects)[id] = this;
            this.id = id;
        }
        /**
         * Time when this server was created
         */
        get createdAt() {
            return new Date((0, ulid_1.decodeTime)(this.id));
        }
        /**
         * Owner
         */
        get owner() {
            return client.users.get(__classPrivateFieldGet(Server, _a, "f", _Server_storage).get(this.id).ownerId);
        }
        /**
         * Name
         */
        get name() {
            return __classPrivateFieldGet(Server, _a, "f", _Server_storage).get(this.id).name;
        }
        /**
         * Description
         */
        get description() {
            return __classPrivateFieldGet(Server, _a, "f", _Server_storage).get(this.id).description;
        }
        /**
         * Icon
         */
        get icon() {
            return __classPrivateFieldGet(Server, _a, "f", _Server_storage).get(this.id).icon;
        }
        /**
         * Banner
         */
        get banner() {
            return __classPrivateFieldGet(Server, _a, "f", _Server_storage).get(this.id).banner;
        }
        /**
         * Channels
         */
        get channels() {
            return [...__classPrivateFieldGet(Server, _a, "f", _Server_storage).get(this.id).channelIds.values()]
                .map((id) => client.channels.get(id))
                .filter((x) => x);
        }
        /**
         * Categories
         */
        get categories() {
            return __classPrivateFieldGet(Server, _a, "f", _Server_storage).get(this.id).categories;
        }
        /**
         * System message channels
         */
        get systemMessages() {
            return __classPrivateFieldGet(Server, _a, "f", _Server_storage).get(this.id).systemMessages;
        }
        /**
         * Roles
         */
        get roles() {
            return __classPrivateFieldGet(Server, _a, "f", _Server_storage).get(this.id).roles;
        }
        /**
         * Default permissions
         */
        get defaultPermissions() {
            return __classPrivateFieldGet(Server, _a, "f", _Server_storage).get(this.id).defaultPermissions;
        }
        /**
         * Server flags
         */
        get flags() {
            return __classPrivateFieldGet(Server, _a, "f", _Server_storage).get(this.id).flags;
        }
        /**
         * Whether analytics are enabled for this server
         */
        get analytics() {
            return __classPrivateFieldGet(Server, _a, "f", _Server_storage).get(this.id).analytics;
        }
        /**
         * Whether this server is publicly discoverable
         */
        get discoverable() {
            return __classPrivateFieldGet(Server, _a, "f", _Server_storage).get(this.id).discoverable;
        }
        /**
         * Whether this server is marked as mature
         */
        get mature() {
            return __classPrivateFieldGet(Server, _a, "f", _Server_storage).get(this.id).nsfw;
        }
        /**
         * Get an array of ordered categories with their respective channels.
         * Uncategorised channels are returned in `id="default"` category.
         */
        get orderedChannels() {
            const uncategorised = new Set(this.channels.map((channel) => channel.id));
            const elements = [];
            let defaultCategory;
            const categories = this.categories;
            if (categories) {
                for (const category of categories) {
                    const channels = [];
                    for (const key of category.channels) {
                        if (uncategorised.delete(key)) {
                            channels.push(client.channels.get(key));
                        }
                    }
                    const cat = Object.assign(Object.assign({}, category), { channels });
                    if (cat.id === "default") {
                        if (channels.length === 0)
                            continue;
                        defaultCategory = cat;
                    }
                    elements.push(cat);
                }
            }
            if (uncategorised.size > 0) {
                const channels = [...uncategorised].map((key) => client.channels.get(key));
                if (defaultCategory) {
                    defaultCategory.channels = [...defaultCategory.channels, ...channels];
                }
                else {
                    elements.unshift({
                        id: "default",
                        title: "Default",
                        channels,
                    });
                }
            }
            return elements;
        }
        /**
         * Default channel for this server
         */
        get defaultChannel() {
            var _a;
            return (_a = this.orderedChannels.find((cat) => cat.channels.length)) === null || _a === void 0 ? void 0 : _a.channels[0];
        }
        /**
         * Get an ordered array of roles with their IDs attached.
         * The highest ranking roles will be first followed by lower
         * ranking roles. This is dictated by the "rank" property
         * which is smaller for higher priority roles.
         */
        get orderedRoles() {
            const roles = this.roles;
            return roles
                ? [...roles.entries()]
                    .map(([id, role]) => (Object.assign({ id }, role)))
                    .sort((a, b) => (a.rank || 0) - (b.rank || 0))
                : [];
        }
    },
    _Server_storage = { value: new ObjectStorage_1.ObjectStorage() },
    _Server_objects = { value: {} },
    _a; };
