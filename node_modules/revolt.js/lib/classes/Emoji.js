"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
Object.defineProperty(exports, "__esModule", { value: true });
const ulid_1 = require("ulid");
const ObjectStorage_1 = require("../storage/ObjectStorage");
exports.default = (client) => { var _a, _Emoji_storage, _Emoji_objects; return _a = 
/**
 * Emoji Class
 */
class Emoji {
        /**
         * Get an existing Emoji
         * @param id Emoji ID
         * @returns Emoji
         */
        static get(id) {
            return __classPrivateFieldGet(Emoji, _a, "f", _Emoji_objects)[id];
        }
        /**
         * Fetch emoji by ID
         * @param id ID
         * @returns Emoji
         */
        static fetch(id) {
            return __awaiter(this, void 0, void 0, function* () {
                const emoji = Emoji.get(id);
                if (emoji)
                    return emoji;
                const data = yield client.api.get(`/custom/emoji/${id}`);
                return new Emoji(id, data);
            });
        }
        /**
         * Construct Emoji
         * @param id Emoji Id
         */
        constructor(id, data) {
            __classPrivateFieldGet(Emoji, _a, "f", _Emoji_storage).hydrate(id, "emoji", data);
            __classPrivateFieldGet(Emoji, _a, "f", _Emoji_objects)[id] = this;
            this.id = id;
        }
        /**
         * Time when this emoji was created
         */
        get createdAt() {
            return new Date((0, ulid_1.decodeTime)(this.id));
        }
        /**
         * Information about the parent of this emoji
         */
        get parent() {
            return __classPrivateFieldGet(Emoji, _a, "f", _Emoji_storage).get(this.id).parent;
        }
        /**
         * Creator of the emoji
         */
        get creator() {
            return client.users.get(__classPrivateFieldGet(Emoji, _a, "f", _Emoji_storage).get(this.id).creatorId);
        }
        /**
         * Name
         */
        get name() {
            return __classPrivateFieldGet(Emoji, _a, "f", _Emoji_storage).get(this.id).name;
        }
        /**
         * Whether the emoji is animated
         */
        get animated() {
            return __classPrivateFieldGet(Emoji, _a, "f", _Emoji_storage).get(this.id).animated;
        }
        /**
         * Whether the emoji is marked as mature
         */
        get mature() {
            return __classPrivateFieldGet(Emoji, _a, "f", _Emoji_storage).get(this.id).nsfw;
        }
    },
    _Emoji_storage = { value: new ObjectStorage_1.ObjectStorage() },
    _Emoji_objects = { value: {} },
    _a; };
