import { createSignal } from "solid-js";
import EventEmitter from "eventemitter3";
import WebSocket from "isomorphic-ws";
/**
 * All possible event client states.
 */
export var ConnectionState;
(function (ConnectionState) {
    ConnectionState[ConnectionState["Idle"] = 0] = "Idle";
    ConnectionState[ConnectionState["Connecting"] = 1] = "Connecting";
    ConnectionState[ConnectionState["Connected"] = 2] = "Connected";
    ConnectionState[ConnectionState["Disconnected"] = 3] = "Disconnected";
})(ConnectionState || (ConnectionState = {}));
/**
 * Simple wrapper around the Revolt websocket service.
 */
export class EventClient extends EventEmitter {
    options;
    #protocolVersion;
    #transportFormat;
    ping;
    #setPing;
    state;
    #setStateSetter;
    #socket;
    #heartbeatIntervalReference;
    #pongTimeoutReference;
    /**
     * Create a new event client.
     * @param protocolVersion Target protocol version
     * @param transportFormat Communication format
     * @param options Configuration options
     */
    constructor(protocolVersion, transportFormat = "json", options) {
        super();
        this.#protocolVersion = protocolVersion;
        this.#transportFormat = transportFormat;
        this.options = {
            heartbeatInterval: 30,
            pongTimeout: 10,
            debug: false,
            ...options,
        };
        const [state, setState] = createSignal(ConnectionState.Idle);
        this.state = state;
        this.#setStateSetter = setState;
        const [ping, setPing] = createSignal(-1);
        this.ping = ping;
        this.#setPing = setPing;
        this.disconnect = this.disconnect.bind(this);
    }
    /**
     * Set the current state
     * @param state state
     */
    setState(state) {
        this.#setStateSetter(state);
        this.emit("state", state);
    }
    /**
     * Connect to the websocket service.
     * @param uri WebSocket URI
     * @param token Authentication token
     */
    connect(uri, token) {
        this.disconnect();
        this.setState(ConnectionState.Connecting);
        this.#socket = new WebSocket(`${uri}?version=${this.#protocolVersion}&format=${this.#transportFormat}&token=${token}`);
        this.#socket.onopen = () => {
            this.#heartbeatIntervalReference = setInterval(() => {
                this.send({ type: "Ping", data: +new Date() });
                this.#pongTimeoutReference = setTimeout(() => this.disconnect(), this.options.pongTimeout * 1e3);
            }, this.options.heartbeatInterval * 1e3);
        };
        this.#socket.onerror = (error) => {
            this.emit("error", error);
        };
        this.#socket.onmessage = (event) => {
            if (this.#transportFormat === "json") {
                if (typeof event.data === "string") {
                    this.handle(JSON.parse(event.data));
                }
            }
        };
        let closed = false;
        this.#socket.onclose = () => {
            if (closed)
                return;
            closed = true;
            this.disconnect();
        };
    }
    /**
     * Disconnect the websocket client.
     */
    disconnect() {
        if (!this.#socket)
            return;
        clearInterval(this.#heartbeatIntervalReference);
        const socket = this.#socket;
        this.#socket = undefined;
        socket.close();
        this.setState(ConnectionState.Disconnected);
    }
    /**
     * Send an event to the server.
     * @param event Event
     */
    send(event) {
        this.options.debug && console.debug("[C->S]", event);
        if (!this.#socket)
            throw "Socket closed, trying to send.";
        this.#socket.send(JSON.stringify(event));
    }
    /**
     * Handle events intended for client before passing them along.
     * @param event Event
     */
    handle(event) {
        this.options.debug && console.debug("[S->C]", event);
        switch (event.type) {
            case "Ping":
                this.send({
                    type: "Pong",
                    data: event.data,
                });
                return;
            case "Pong":
                clearTimeout(this.#pongTimeoutReference);
                this.#setPing(+new Date() - event.data);
                this.options.debug && console.debug(`[ping] ${this.ping()}ms`);
                return;
            case "Error":
                this.emit("error", event);
                this.disconnect();
                return;
        }
        switch (this.state()) {
            case ConnectionState.Connecting:
                if (event.type === "Authenticated") {
                    // no-op
                }
                else if (event.type === "Ready") {
                    this.emit("event", event);
                    this.setState(ConnectionState.Connected);
                }
                else {
                    throw `Unreachable code. Received ${event.type} in Connecting state.`;
                }
                break;
            case ConnectionState.Connected:
                if (event.type === "Authenticated" || event.type === "Ready") {
                    throw `Unreachable code. Received ${event.type} in Connected state.`;
                }
                else {
                    this.emit("event", event);
                }
                break;
            default:
                throw `Unreachable code. Received ${event.type} in state ${this.state()}.`;
        }
    }
}
