import { Accessor } from "solid-js";
import EventEmitter from "eventemitter3";
import { API, Role } from "revolt-api";
import type { DataLogin, RevoltConfig } from "revolt-api";
import { Channel, Emoji, Message, Server, ServerMember, User } from "./classes";
import { BotCollection, ChannelCollection, ChannelUnreadCollection, ChannelWebhookCollection, EmojiCollection, MessageCollection, ServerCollection, ServerMemberCollection, SessionCollection, UserCollection } from "./collections";
import { AccountCollection } from "./collections/AccountCollection";
import { EventClient, EventClientOptions } from "./events";
import { HydratedChannel, HydratedEmoji, HydratedMessage, HydratedServer, HydratedServerMember, HydratedUser } from "./hydration";
export type Session = {
    _id: string;
    token: string;
    user_id: string;
} | string;
/**
 * Events provided by the client
 */
type Events = {
    error(error: Error): void;
    connected(): void;
    connecting(): void;
    disconnected(): void;
    ready(): void;
    logout(): void;
    messageCreate(message: Message): void;
    messageUpdate(message: Message, previousMessage: HydratedMessage): void;
    messageDelete(message: HydratedMessage): void;
    messageDeleteBulk(messages: HydratedMessage[], channel?: Channel): void;
    messageReactionAdd(message: Message, userId: string, emoji: string): void;
    messageReactionRemove(message: Message, userId: string, emoji: string): void;
    messageReactionRemoveEmoji(message: Message, emoji: string): void;
    channelCreate(channel: Channel): void;
    channelUpdate(channel: Channel, previousChannel: HydratedChannel): void;
    channelDelete(channel: HydratedChannel): void;
    channelGroupJoin(channel: Channel, user: User): void;
    channelGroupLeave(channel: Channel, user?: User): void;
    channelStartTyping(channel: Channel, user?: User): void;
    channelStopTyping(channel: Channel, user?: User): void;
    channelAcknowledged(channel: Channel, messageId: string): void;
    serverCreate(server: Server): void;
    serverUpdate(server: Server, previousServer: HydratedServer): void;
    serverDelete(server: HydratedServer): void;
    serverRoleUpdate(server: Server, roleId: string, previousRole: Role): void;
    serverRoleDelete(server: Server, roleId: string, role: Role): void;
    serverMemberUpdate(member: ServerMember, previousMember: HydratedServerMember): void;
    serverMemberJoin(member: ServerMember): void;
    serverMemberLeave(member: HydratedServerMember): void;
    userUpdate(user: User, previousUser: HydratedUser): void;
    userSettingsUpdate(id: string, update: Record<string, [number, string]>): void;
    emojiCreate(emoji: Emoji): void;
    emojiDelete(emoji: HydratedEmoji): void;
};
/**
 * Client options object
 */
export type ClientOptions = Partial<EventClientOptions> & {
    /**
     * Base URL of the API server
     */
    baseURL: string;
    /**
     * Whether to allow partial objects to emit from events
     * @default false
     */
    partials: boolean;
    /**
     * Whether to eagerly fetch users and members for incoming events
     * @default true
     * @deprecated
     */
    eagerFetching: boolean;
    /**
     * Whether to automatically sync unreads information
     * @default false
     */
    syncUnreads: boolean;
    /**
     * Whether to reconnect when disconnected
     * @default true
     */
    autoReconnect: boolean;
    /**
     * Retry delay function
     * @param retryCount Count
     * @returns Delay in seconds
     * @default (2^x-1) Â±20%
     */
    retryDelayFunction(retryCount: number): number;
    /**
     * Check whether a channel is muted
     * @param channel Channel
     * @return Whether it is muted
     * @default false
     */
    channelIsMuted(channel: Channel): boolean;
};
/**
 * Revolt.js Clients
 */
export declare class Client extends EventEmitter<Events> {
    #private;
    readonly account: AccountCollection;
    readonly bots: BotCollection;
    readonly channels: ChannelCollection;
    readonly channelUnreads: ChannelUnreadCollection;
    readonly channelWebhooks: ChannelWebhookCollection;
    readonly emojis: EmojiCollection;
    readonly messages: MessageCollection;
    readonly servers: ServerCollection;
    readonly serverMembers: ServerMemberCollection;
    readonly sessions: SessionCollection;
    readonly users: UserCollection;
    readonly api: API;
    readonly options: ClientOptions;
    readonly events: EventClient<1>;
    configuration: RevoltConfig | undefined;
    user: User | undefined;
    readonly ready: Accessor<boolean>;
    readonly connectionFailureCount: Accessor<number>;
    /**
     * Create Revolt.js Client
     */
    constructor(options?: Partial<ClientOptions>, configuration?: RevoltConfig);
    /**
     * Current session id
     */
    get sessionId(): string | undefined;
    /**
     * Connect to Revolt
     */
    connect(): void;
    /**
     * Log in with auth data, creating a new session in the process.
     * @param details Login data object
     * @returns An on-boarding function if on-boarding is required, undefined otherwise
     */
    login(details: DataLogin): Promise<void>;
    /**
     * Use an existing session to log into Revolt
     * @param session Session data object
     * @returns An on-boarding function if on-boarding is required, undefined otherwise
     */
    useExistingSession(session: Session): Promise<void>;
    /**
     * Log in as a bot
     * @param token Bot token
     */
    loginBot(token: string): Promise<void>;
    /**
     * Prepare a markdown-based message to be displayed to the user as plain text.
     * @param source Source markdown text
     * @returns Modified plain text
     */
    markdownToText(source: string): string;
    /**
     * Proxy a file through January.
     * @param url URL to proxy
     * @returns Proxied media URL
     */
    proxyFile(url: string): string | undefined;
}
export {};
//# sourceMappingURL=Client.d.ts.map