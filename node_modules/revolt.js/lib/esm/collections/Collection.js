import { ReactiveMap } from "@solid-primitives/map";
import { ObjectStorage } from "../storage/ObjectStorage";
/**
 * Abstract Collection type
 */
export class Collection {
    /**
     * List of values in the map
     * @returns List
     */
    toList() {
        return [...this.values()];
    }
    /**
     * Filter the collection by a given predicate
     * @param predicate Predicate to satisfy
     */
    filter(predicate) {
        const list = [];
        for (const [key, value] of this.entries()) {
            if (predicate(value, key)) {
                list.push(value);
            }
        }
        return list;
    }
    /**
     * Map the collection using a given callback
     * @param cb Callback
     */
    map(cb) {
        const list = [];
        for (const [key, value] of this.entries()) {
            list.push(cb(value, key));
        }
        return list;
    }
    /**
     * Find some value based on a predicate
     * @param predicate Predicate to satisfy
     */
    find(predicate) {
        for (const [key, value] of this.entries()) {
            if (predicate(value, key)) {
                return value;
            }
        }
    }
}
/**
 * Collection backed by a Solid.js Store
 */
export class StoreCollection extends Collection {
    #storage = new ObjectStorage();
    #objects = new ReactiveMap();
    getUnderlyingObject;
    updateUnderlyingObject;
    /**
     * Construct store backed collection
     */
    constructor() {
        super();
        this.getUnderlyingObject = (key) => this.#storage.get(key) ?? {};
        this.updateUnderlyingObject = this.#storage.set;
    }
    /**
     * Get an existing object
     * @param id Id
     * @returns Object
     */
    get(id) {
        return this.#objects.get(id);
    }
    /**
     * Check whether an id exists in the Collection
     * @param id Id
     * @returns Whether it exists
     */
    has(id) {
        return this.#objects.has(id);
    }
    /**
     * Delete an object
     * @param id Id
     */
    delete(id) {
        this.#objects.delete(id);
        this.updateUnderlyingObject(id, undefined);
    }
    /**
     * Create a new instance of an object
     * @param id Id
     * @param type Type
     * @param instance Instance
     * @param context Context
     * @param data Data
     */
    create(id, type, instance, context, data) {
        this.#storage.hydrate(id, type, context, data);
        this.#objects.set(id, instance);
    }
    /**
     * Check whether an object is partially defined
     * @param id Id
     * @returns Whether it is a partial
     */
    isPartial(id) {
        return !!this.getUnderlyingObject(id).partial;
    }
    /**
     * Number of stored objects
     * @returns Size
     */
    size() {
        return this.#objects.size;
    }
    /**
     * Iterable of keys in the map
     * @returns Iterable
     */
    keys() {
        return this.#objects.keys();
    }
    /**
     * Iterable of values in the map
     * @returns Iterable
     */
    values() {
        return this.#objects.values();
    }
    /**
     * Iterable of key, value pairs in the map
     * @returns Iterable
     */
    entries() {
        return this.#objects.entries();
    }
    /**
     * Execute a provided function over each key, value pair in the map
     * @param cb Callback for each pair
     * @returns Iterable
     */
    forEach(cb) {
        return this.#objects.forEach(cb);
    }
}
/**
 * Generic class collection backed by store
 */
export class ClassCollection extends StoreCollection {
    client;
    /**
     * Create generic class collection
     * @param client Client
     */
    constructor(client) {
        super();
        this.client = client;
    }
}
