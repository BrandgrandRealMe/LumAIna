"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _Client_instances, _Client_Emoji, _Client_Channel, _Client_User, _Client_Server, _Client_ServerMember, _Client_fetchConfiguration, _Client_updateHeaders;
Object.defineProperty(exports, "__esModule", { value: true });
exports.Client = void 0;
const revolt_api_1 = require("revolt-api");
const Channel_1 = __importDefault(require("./classes/Channel"));
const Emoji_1 = __importDefault(require("./classes/Emoji"));
const Server_1 = __importDefault(require("./classes/Server"));
const ServerMember_1 = __importDefault(require("./classes/ServerMember"));
const User_1 = __importDefault(require("./classes/User"));
const client_1 = require("./events/client");
/**
 * Revolt.js Client
 */
class Client {
    /**
     * Create Revolt.js Client
     */
    constructor(baseURL) {
        _Client_instances.add(this);
        _Client_Emoji.set(this, (0, Emoji_1.default)(this));
        _Client_Channel.set(this, (0, Channel_1.default)(this));
        _Client_User.set(this, (0, User_1.default)(this));
        _Client_Server.set(this, (0, Server_1.default)(this));
        _Client_ServerMember.set(this, (0, ServerMember_1.default)(this));
        this.emojis = __classPrivateFieldGet(this, _Client_Emoji, "f");
        this.channels = __classPrivateFieldGet(this, _Client_Channel, "f");
        this.users = __classPrivateFieldGet(this, _Client_User, "f");
        this.servers = __classPrivateFieldGet(this, _Client_Server, "f");
        this.serverMembers = __classPrivateFieldGet(this, _Client_ServerMember, "f");
        this.baseURL = baseURL;
        this.api = new revolt_api_1.API({
            baseURL,
        });
        this.events = (0, client_1.createEventClient)(1);
    }
    /**
     * Connect
     */
    connect() {
        this.events.on("event", (event) => {
            var _a;
            console.info("[EVENT]", JSON.stringify(event).substring(0, 32));
            if (event.type === "Ready") {
                console.time("load users");
                for (const user of event.users) {
                    new (__classPrivateFieldGet(this, _Client_User, "f"))(user._id, user);
                }
                console.timeEnd("load users");
                console.time("load servers");
                for (const server of event.servers) {
                    new (__classPrivateFieldGet(this, _Client_Server, "f"))(server._id, server);
                }
                console.timeEnd("load servers");
                console.time("load memberships");
                for (const member of event.members) {
                    new (__classPrivateFieldGet(this, _Client_ServerMember, "f"))(member._id, member);
                }
                console.timeEnd("load memberships");
                console.time("load channels");
                for (const channel of event.channels) {
                    new (__classPrivateFieldGet(this, _Client_Channel, "f"))(channel._id, channel);
                }
                console.timeEnd("load channels");
                console.time("load emojis");
                for (const emoji of event.emojis) {
                    new (__classPrivateFieldGet(this, _Client_Emoji, "f"))(emoji._id, emoji);
                }
                console.timeEnd("load emojis");
                const lounge = this.servers.get("01F7ZSBSFHQ8TA81725KQCSDDP");
                console.info(`The owner of ${lounge.name} is ${lounge.owner.username}!`);
                console.log(lounge.owner);
                console.log("It has the channels:", lounge.channels.map((channel) => channel.name));
                console.log("They joined at:", (_a = this.serverMembers.get({ server: lounge.id, user: lounge.owner.id })) === null || _a === void 0 ? void 0 : _a.joinedAt);
            }
        });
        this.events.on("state", (state) => console.info("STATE =", state));
        this.events.on("error", (error) => console.error("ERROR =", error));
        this.events.connect("wss://ws.revolt.chat", typeof this.session === "string" ? this.session : this.session.token);
    }
    /**
     * Log in with auth data, creating a new session in the process.
     * @param details Login data object
     * @returns An on-boarding function if on-boarding is required, undefined otherwise
     */
    login(details) {
        return __awaiter(this, void 0, void 0, function* () {
            yield __classPrivateFieldGet(this, _Client_instances, "m", _Client_fetchConfiguration).call(this);
            const data = yield this.api.post("/auth/session/login", details);
            if (data.result === "Success") {
                this.session = data;
                // TODO: return await this.connect();
            }
            else {
                throw "MFA not implemented!";
            }
        });
    }
    /**
     * Use an existing session to log into Revolt.
     * @param session Session data object
     * @returns An on-boarding function if on-boarding is required, undefined otherwise
     */
    useExistingSession(session) {
        return __awaiter(this, void 0, void 0, function* () {
            yield __classPrivateFieldGet(this, _Client_instances, "m", _Client_fetchConfiguration).call(this);
            this.session = session;
            __classPrivateFieldGet(this, _Client_instances, "m", _Client_updateHeaders).call(this);
            this.connect();
        });
    }
    /**
     * Log in as a bot.
     * @param token Bot token
     */
    loginBot(token) {
        return __awaiter(this, void 0, void 0, function* () {
            yield __classPrivateFieldGet(this, _Client_instances, "m", _Client_fetchConfiguration).call(this);
            this.session = token;
            __classPrivateFieldGet(this, _Client_instances, "m", _Client_updateHeaders).call(this);
            this.connect();
        });
    }
}
exports.Client = Client;
_Client_Emoji = new WeakMap(), _Client_Channel = new WeakMap(), _Client_User = new WeakMap(), _Client_Server = new WeakMap(), _Client_ServerMember = new WeakMap(), _Client_instances = new WeakSet(), _Client_fetchConfiguration = function _Client_fetchConfiguration() {
    return __awaiter(this, void 0, void 0, function* () {
        if (!this.configuration) {
            this.configuration = yield this.api.get("/");
        }
    });
}, _Client_updateHeaders = function _Client_updateHeaders() {
    this.api = new revolt_api_1.API({
        baseURL: this.baseURL,
        authentication: {
            revolt: this.session,
        },
    });
};
